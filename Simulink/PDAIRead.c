/*
* File: PDAIRead.c
*
*
*
*   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 2.0 ---
*
*   This file is an S-function produced by the S-Function
*   Builder which only recognizes certain fields.  Changes made
*   outside these fields will be lost the next time the block is
*   used to load, edit, and resave this file. This file will be overwritten
*   by the S-function Builder block. If you want to edit this file by hand, 
*   you must change it only in the area defined as:  
*
*        %%%-SFUNWIZ_defines_Changes_BEGIN
*        #define NAME 'replacement text' 
*        %%% SFUNWIZ_defines_Changes_END
*
*   DO NOT change NAME--Change the 'replacement text' only.
*
*   For better compatibility with the Real-Time Workshop, the
*   "wrapper" S-function technique is used.  This is discussed
*   in the Real-Time Workshop User's Manual in the Chapter titled,
*   "Wrapper S-functions".
*
*  -------------------------------------------------------------------------
* | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
*  ------------------------------------------------------------------------- 
* Created: Wed Oct 12 12:15:11 2005
* 
*
*/
#include <math.h>
#include "win_sdk_types.h"
#if defined(_WIN32)
   #include "pwrdaq32.h"
   #include "pwrdaq.h"
#else
   #include <signal.h>
   #include "powerdaq.h"
   #include "powerdaq32.h"
#endif
#include "pdfw_def.h"

#if defined(_WIN32) && defined(MATLAB_MEX_FILE)  
void __stdcall Sleep(DWORD dwMilliseconds);
#endif

#if defined(_WIN32)
#define errorChk(functionCall) { BOOL bResult; DWORD error=0;\
                                 if(!(bResult=functionCall)) { \
	                                 sprintf(errorMsg, "Error %d at line %d in function call %s\n", error, __LINE__, #functionCall); \
	                                 ssSetErrorStatus(S, errorMsg); \
                                    return; \
                               }}
#else
#define errorChk(functionCall) { int error=0;\
                                 if((error=functionCall) < 0) { \
	                                 sprintf(errorMsg, "Error %d at line %d in function call %s\n", error, __LINE__, #functionCall); \
	                                 ssSetErrorStatus(S, errorMsg); \
                                    return; \
                               }}
#endif                               

typedef enum _state
{
   closed,
   unconfigured,
   configured,
   running
} tState;

typedef struct _singleAiData
{
   int board;                    /* board number to be used for the AI operation */
   int nbOfBoards;              /* number of boards installed */
   HANDLE handle;                /* board handle */
   HANDLE driver;
   int nbOfChannels;             /* number of channels */
   int nbOfSamplesPerChannel;    /* number of samples per channel */
   unsigned long channelList[PD_MAX_CL_SIZE];
   unsigned long aiCfg;
   double scanRate;              /* sampling frequency on each channel */
   int polarity;                 /* polarity of the signal to acquire, possible value */
   /* is AIN_UNIPOLAR or AIN_BIPOLAR */
   int range;                    /* range of the signal to acquire, possible value */
   /* is AIN_RANGE_5V or AIN_RANGE_10V */
   int inputMode;                /* input mode possible value is AIN_SINGLE_ENDED or AIN_DIFFERENTIAL */
   int trigger;
   double gain[PD_MAX_CL_SIZE];
   short* rawBuffer;
   tState state;                 /* state of the acquisition session */
   double minRange;
   double maxRange;
   Adapter_Info adaptInfo;
   double bitWeight;
   double offset;
} tSingleAiData;
 

#define S_FUNCTION_NAME PDAIRead
#define S_FUNCTION_LEVEL 2
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */
/* Output Port  0 */
#define OUT_PORT_0_NAME      y0
#define OUTPUT_0_WIDTH       1
#define OUTPUT_DIMS_0_COL    1
#define OUTPUT_0_DTYPE       real_T
#define OUTPUT_0_COMPLEX     COMPLEX_NO
#define OUT_0_FRAME_BASED    FRAME_NO
#define OUT_0_DIMS           1-D

#define NUM_PARAMS              6 

#include "simstruc.h"
#define PD_BOARD_PARAM(S)     ssGetSFcnParam(S, 0)
#define PD_MIN_RANGE_PARAM(S) ssGetSFcnParam(S, 1)
#define PD_MAX_RANGE_PARAM(S) ssGetSFcnParam(S, 2)
#define PD_INPUT_MODE_PARAM(S) ssGetSFcnParam(S,3)
#define PD_CHANNEL_LIST_PARAM(S) ssGetSFcnParam(S, 4)
#define PD_SAMPLE_TIME_PARAM(S)  ssGetSFcnParam(S, 5)

#define IS_PARAM_INT32(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\
!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsInt32(pVal))

#define IS_PARAM_DOUBLE(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\
!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsDouble(pVal))


/*====================*
* S-function methods *
*====================*/
#define MDL_CHECK_PARAMETERS
#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)
/* Function: mdlCheckParameters =============================================
* Abstract:
*    Validate our parameters to verify they are okay.
*/
static void mdlCheckParameters(SimStruct *S)
{
#define PrmNumPos 46
   int paramIndex = 0;
   bool validParam = false;
   char paramVector[] ={'1','2','3','4','5','6'};
   static char parameterErrorMsg[] ="The data type and/or complexity of parameter    does not match the information "
      "specified in the S-function Builder dialog. For non-double parameters you will need to cast them using int8, int16,"
      "int32, uint8, uint16, uint32 or boolean."; 
   
   /* All parameters must match the S-function Builder Dialog */
   
   
   {
      const mxArray *pVal = PD_BOARD_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 0;
         goto EXIT_POINT;
      }
   }
   
   {
      const mxArray *pVal = PD_MIN_RANGE_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 1;
         goto EXIT_POINT;
      }
   }
   
   {
      const mxArray *pVal = PD_MAX_RANGE_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 2;
         goto EXIT_POINT;
      }
   }

   {
      const mxArray *pVal = PD_INPUT_MODE_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 3;
         goto EXIT_POINT;
      }
   }
   
   {
      const mxArray *pVal = PD_CHANNEL_LIST_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 4;
         goto EXIT_POINT;
      }
   }

   {
      const mxArray *pVal = PD_SAMPLE_TIME_PARAM(S);
      if (!IS_PARAM_DOUBLE(pVal)) 
      {
         validParam = true;
         paramIndex = 5;
         goto EXIT_POINT;
      }
   }
EXIT_POINT:
   if (validParam) 
   {
      parameterErrorMsg[PrmNumPos] = paramVector[paramIndex];
      ssSetErrorStatus(S,parameterErrorMsg);
   }
   return;
}
#endif /* MDL_CHECK_PARAMETERS */
/* Function: mdlInitializeSizes ===============================================
* Abstract:
*   Setup sizes of the various vectors.
*/
static void mdlInitializeSizes(SimStruct *S)
{
   int i;

   ssSetNumSFcnParams(S, NUM_PARAMS);  /* Number of expected parameters */
#if defined(MATLAB_MEX_FILE)
   if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) 
   {
      mdlCheckParameters(S);
      if (ssGetErrorStatus(S) != NULL) 
      {
         return;
      }
   } 
   else 
   {
      return; /* Parameter mismatch will be reported by Simulink */
   }
#endif
   
   ssSetNumContStates(S, 0);
   ssSetNumDiscStates(S, 0);
   
   if (!ssSetNumInputPorts(S, 0)) 
      return;

   ssSetNumOutputPorts(S, mxGetN(PD_CHANNEL_LIST_PARAM(S)));
   for (i=0;i<mxGetN(PD_CHANNEL_LIST_PARAM(S));i++) 
   {
      ssSetOutputPortWidth(S, i, 1);
      ssSetOutputPortDataType(S, i, SS_DOUBLE);
      ssSetOutputPortComplexSignal(S, i, COMPLEX_NO);
   }

   ssSetNumSampleTimes(S, 1);
   ssSetNumRWork(S, 0);
   ssSetNumIWork(S, 0);
   ssSetNumPWork(S, 1);
   ssSetNumModes(S, 0);
   ssSetNumNonsampledZCs(S, 0);
   
   /* Take care when specifying exception free code - see sfuntmpl_doc.c */
   ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
      /*SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE |*/
      SS_OPTION_USE_TLC_WITH_ACCELERATOR /*|
      SS_OPTION_WORKS_WITH_CODE_REUSE*/));
}

/* Function: mdlInitializeSampleTimes =========================================
* Abstract:
*    Specifiy  the sample time.
*/
static void mdlInitializeSampleTimes(SimStruct *S)
{
   ssSetSampleTime(S, 0, (time_T)mxGetPr(PD_SAMPLE_TIME_PARAM(S))[0]);
   ssSetOffsetTime(S, 0, 0.0);
}


#define MDL_START  /* Change to #undef to remove function */
#if defined(MDL_START) 
/* Function: mdlStart =======================================================
* Abstract:
*    This function is called once at start of model execution. If you
*    have states that should be initialized once, this is the place
*    to do it.
*/
static void mdlStart(SimStruct *S)
{
   static char errorMsg[256];
   tSingleAiData* pAiData;
   double minInputRange = -10.0;
   double maxInputRange = 10.0;
   double bestDiff = 999999.0;
   int i;
   int gainIndex = 0;
 

   if(ssGetSimMode(S) != SS_SIMMODE_NORMAL)
   {
      return;
   }

   pAiData = (tSingleAiData*)mxCalloc(1, sizeof(tSingleAiData));
   if(!pAiData)
   {
      sprintf(errorMsg, "Error allocating memory\n");
      ssSetErrorStatus(S, errorMsg);
      return;
   }

   pAiData->board = (int)(mxGetPr(PD_BOARD_PARAM(S))[0]);
   pAiData->handle = 0;
   pAiData->scanRate = 1.0/(real_T)(mxGetPr(PD_SAMPLE_TIME_PARAM(S))[0]);
   pAiData->minRange = (real_T)(mxGetPr(PD_MIN_RANGE_PARAM(S))[0]);
   pAiData->maxRange = (real_T)(mxGetPr(PD_MAX_RANGE_PARAM(S))[0]);
   pAiData->nbOfChannels = mxGetN(PD_CHANNEL_LIST_PARAM(S));
   pAiData->nbOfSamplesPerChannel = 1;
   pAiData->state = closed;
   pAiData->trigger = 0; 

   if((real_T)(mxGetPr(PD_INPUT_MODE_PARAM(S))[0]) > 1.0)
   {
      pAiData->inputMode = AIN_DIFFERENTIAL;
   } 
   else
   {
      pAiData->inputMode = AIN_SINGLE_ENDED;
   }
   
   printf("Input mode is %s (%f)\n", pAiData->inputMode ? "Differential" : "Single-ended",
          (real_T)(mxGetPr(PD_INPUT_MODE_PARAM(S))[0]));

   /* Select best polarity and range for the requested input range */
   if(pAiData->minRange < 0.0)
   {
      pAiData->polarity = AIN_BIPOLAR;
      minInputRange = -5.0;
      maxInputRange = 5.0;
      pAiData->bitWeight=10.0/65536.0;
      pAiData->offset = 0.0;
   }
   else
   {
      pAiData->polarity = AIN_UNIPOLAR;
      minInputRange = 0.0;
      maxInputRange = 5.0;
      pAiData->bitWeight=5.0/65536.0;
      pAiData->offset = 2.5;
   }

   if(pAiData->minRange < -5.0 || pAiData->maxRange > 5.0)
   {
      pAiData->range = AIN_RANGE_10V;
      minInputRange = minInputRange*2;
      maxInputRange = maxInputRange*2;
      pAiData->bitWeight = pAiData->bitWeight*2;
      pAiData->offset = pAiData->offset*2;
   }
   else
   {
      pAiData->range = AIN_RANGE_5V;
   }

   pAiData->aiCfg = AIB_CVSTART0 | AIB_CVSTART1 | pAiData->range | pAiData->inputMode | 
                    pAiData->polarity | pAiData->trigger;

   printf("minrange=%f(%f), maxrange=%f(%f), aiCfg=0x%x\n", pAiData->minRange, minInputRange, 
          pAiData->maxRange, maxInputRange, pAiData->aiCfg);


   /* allocate memory for the buffer that will receive binary data from the board */
   pAiData->rawBuffer = (short*)mxCalloc(pAiData->nbOfSamplesPerChannel*
                                         pAiData->nbOfChannels, sizeof(short));
   if(pAiData->rawBuffer == NULL)
   {
      sprintf(errorMsg, "Error allocating raw buffer\n");
      ssSetErrorStatus(S, errorMsg);
      mxFree(pAiData);
      return;
   }

#if defined(_WIN32)
   errorChk(PdDriverOpen(&pAiData->driver, &error, &pAiData->nbOfBoards));
   errorChk(_PdGetAdapterInfo(pAiData->board, &error, &pAiData->adaptInfo));
   errorChk(_PdAdapterOpen(pAiData->board, &error, &pAiData->handle));   
   errorChk(PdAdapterAcquireSubsystem(pAiData->handle, &error, AnalogIn, 1));
#else  
   errorChk(_PdGetAdapterInfo(pAiData->board, &pAiData->adaptInfo));
   pAiData->handle = PdAcquireSubsystem(pAiData->board, AnalogIn, 1);
   if(pAiData->handle < 0) 
   { 
	  sprintf(errorMsg, "Error acquiring AnalogIn subsystem\n");
	  ssSetErrorStatus(S, errorMsg);
      return;
   }
#endif
   if(!(pAiData->adaptInfo.atType & atMF))
   {
      sprintf(errorMsg, "The specified board doesn't have any analog inputs\n");
	  ssSetErrorStatus(S, errorMsg);
      return;
   }

   if(pAiData->nbOfChannels > pAiData->adaptInfo.SSI[AnalogIn].dwChannels)
   {
      sprintf(errorMsg, "The specified board doesn't have enough analog output channels\n");
	  ssSetErrorStatus(S, errorMsg);
      return;
   }

   /* Calculate the best gain for the requested input range */
   for(i=0; i<pAiData->adaptInfo.SSI[AnalogIn].dwMaxGains; i++)
   {
      if((fabs(maxInputRange / pAiData->adaptInfo.SSI[AnalogIn].fGains[i] - pAiData->maxRange) < bestDiff) &&
         ((maxInputRange / pAiData->adaptInfo.SSI[AnalogIn].fGains[i]) >= pAiData->maxRange) &&
         ((minInputRange / pAiData->adaptInfo.SSI[AnalogIn].fGains[i]) <= pAiData->minRange))
      {
         bestDiff = maxInputRange / pAiData->adaptInfo.SSI[AnalogIn].fGains[i] - pAiData->maxRange;
         gainIndex = i;
      }
   }

   for(i=0; i<pAiData->nbOfChannels; i++)
   {
      pAiData->channelList[i] = (int_T)mxGetPr(PD_CHANNEL_LIST_PARAM(S))[i] | ((gainIndex & 0x03) << 6);
      pAiData->gain[i] = pAiData->adaptInfo.SSI[AnalogIn].fGains[gainIndex];
      printf("Channel %d gain is %f\n", pAiData->channelList[i]&0x3F, pAiData->gain[i]);  
   }

   pAiData->state = unconfigured;

#if defined(_WIN32)
   errorChk(_PdAInReset(pAiData->handle, &error));
   errorChk(_PdAInSetCfg(pAiData->handle, &error, pAiData->aiCfg, 0, 0));
   errorChk(_PdAInSetChList(pAiData->handle, &error, pAiData->nbOfChannels, 
                            (DWORD*)pAiData->channelList));
#else      
   errorChk(_PdAInReset(pAiData->handle));
   errorChk(_PdAInSetCfg(pAiData->handle, pAiData->aiCfg, 0, 0));
   errorChk(_PdAInSetChList(pAiData->handle, pAiData->nbOfChannels, 
                            (DWORD*)pAiData->channelList));
#endif
      
   pAiData->state = configured;

#if defined(_WIN32)
   errorChk(_PdAInEnableConv(pAiData->handle, &error, 1));
   errorChk(_PdAInSwStartTrig(pAiData->handle, &error));
#else
   errorChk(_PdAInEnableConv(pAiData->handle, 1));
   errorChk(_PdAInSwStartTrig(pAiData->handle));
#endif

   pAiData->state = running;

   ssGetPWork(S)[0] = (void*)pAiData;
}
#endif /*  MDL_START */

#define MDL_SET_OUTPUT_PORT_DATA_TYPE
static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)
{
   int i;

   for (i=0;i<mxGetN(PD_CHANNEL_LIST_PARAM(S));i++) 
   {
      ssSetOutputPortDataType(S, i, dType);
   }
}

#define MDL_SET_DEFAULT_PORT_DATA_TYPES
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
   int i;

   for (i=0;i<mxGetN(PD_CHANNEL_LIST_PARAM(S));i++) 
   {
      ssSetOutputPortDataType(S, i, SS_DOUBLE);
   }
}
/* Function: mdlOutputs =======================================================
*
*/
static void mdlOutputs(SimStruct *S, int_T tid)
{
   static char errorMsg[256];
   tSingleAiData* pAiData = (tSingleAiData*)ssGetPWork(S)[0];
   real_T        *y;
   unsigned int i,k;
   unsigned int numSamples;
   int channelsLeft;
   
   if(ssGetSimMode(S) != SS_SIMMODE_NORMAL)
   {
      return;
   }
             
/* When running in simulation mode in simulink */
/* simulate real-time */
#if defined(MATLAB_MEX_FILE)
   #if defined(_WIN32) 
      Sleep((DWORD)floor(1.0E3/pAiData->scanRate));
   #else
      usleep((useconds_t)floor(1.0E6/pAiData->scanRate));
   #endif
#endif

   /* Start acquisition of data for next step */
#if defined(_WIN32)
   errorChk(_PdAInSwClStart(pAiData->handle, &error));
#else
   errorChk(_PdAInSwClStart(pAiData->handle));
#endif

   channelsLeft= pAiData->nbOfChannels;

   k=0;
   while (channelsLeft)
   {
#if defined(_WIN32)
      errorChk(_PdAInGetSamples(pAiData->handle, &error, pAiData->nbOfChannels * 
               pAiData->nbOfSamplesPerChannel, pAiData->rawBuffer, &numSamples));
#else
      errorChk(_PdAInGetSamples(pAiData->handle, pAiData->nbOfChannels * 
               pAiData->nbOfSamplesPerChannel, pAiData->rawBuffer, &numSamples));
#endif   
      

      channelsLeft= channelsLeft - numSamples;
      for (i=0; i<numSamples; i++)
      {
         y=ssGetOutputPortSignal(S,k);
         y[0]=  (pAiData->rawBuffer[i] * pAiData->bitWeight + pAiData->offset) /
                 pAiData->gain[k];
         k++;
      }
   }
}



/* Function: mdlTerminate =====================================================
* Abstract:
*    In this function, you should perform any actions that are necessary
*    at the termination of a simulation.  For example, if memory was
*    allocated in mdlStart, this is the place to free it.
*/
static void mdlTerminate(SimStruct *S)
{
   static char errorMsg[256];
   tSingleAiData* pAiData = (tSingleAiData*)ssGetPWork(S)[0];

   if(ssGetSimMode(S) != SS_SIMMODE_NORMAL)
   {
      return;
   }


   if(pAiData->state == running)
   {
      pAiData->state = configured;
   }
   
   if(pAiData->state == configured)
   {
#if defined(_WIN32)
      errorChk(_PdAInReset(pAiData->handle, &error));
#else
      errorChk(_PdAInReset(pAiData->handle));
#endif
      pAiData->state = unconfigured;
   }
   
   if(pAiData->handle > 0 && pAiData->state == unconfigured)
   {
#if defined(_WIN32)
      errorChk(PdAdapterAcquireSubsystem(pAiData->handle, &error, AnalogIn, 0));
      errorChk(_PdAdapterClose(pAiData->handle, &error));
      errorChk(PdDriverClose(pAiData->driver, &error));
#else
      errorChk(PdAcquireSubsystem(pAiData->handle, AnalogIn, 0));
#endif
   }
   
   pAiData->state = closed;

   mxFree(pAiData->rawBuffer);
   mxFree(pAiData);
}

#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif


